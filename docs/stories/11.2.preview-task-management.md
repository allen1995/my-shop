# Story 11.2: 预览图片生成任务管理

## Status

Ready

## Story

**As a** developer,
**I want** to manage image edit tasks for preview generation,
**so that** preview requests can be tracked and managed properly.

## Acceptance Criteria

1. 创建PreviewTask实体，记录预览生成任务
2. 任务状态包含：PENDING、PROCESSING、COMPLETED、FAILED
3. 支持任务进度查询
4. 实现任务队列管理（避免重复生成）
5. 任务完成后通知前端
6. 失败任务自动重试（最多3次）
7. 任务结果缓存机制

## Tasks / Subtasks

- [x] Task 1: 创建PreviewTask实体 (AC: 1, 2)
  - [x] 创建PreviewTask实体类
  - [x] 字段：id、userId、workId、productId、color、size、status、resultUrl、errorMessage、retryCount、createTime、updateTime
  - [x] 创建PreviewTaskRepository
  - [x] 定义任务状态枚举

- [x] Task 2: 实现任务创建逻辑 (AC: 4)
  - [x] 检查是否存在相同参数的任务
  - [x] 如果存在且状态为COMPLETED，直接返回缓存结果
  - [x] 如果存在且状态为PROCESSING，返回任务ID供轮询
  - [x] 否则创建新任务

- [x] Task 3: 实现任务进度查询 (AC: 3)
  - [x] 提供查询任务状态的API
  - [x] 返回任务状态、进度、结果URL等
  - [x] 支持批量查询

- [x] Task 4: 实现任务执行逻辑 (AC: 5)
  - [x] 创建任务后异步调用ImageEditService
  - [x] 更新任务状态为PROCESSING
  - [x] 生成完成后更新状态为COMPLETED并保存结果URL
  - [x] 生成失败后更新状态为FAILED并记录错误信息

- [x] Task 5: 实现自动重试机制 (AC: 6)
  - [x] 生成失败时检查重试次数
  - [x] 如果重试次数小于3，自动重试
  - [x] 重试间隔：5秒、10秒、20秒（指数退避）
  - [x] 记录重试日志

- [x] Task 6: 实现结果缓存 (AC: 7)
  - [x] 相同参数的任务结果缓存7天
  - [x] 使用Redis或数据库缓存
  - [x] 缓存key：workId-productId-color-size
  - [x] 支持手动清除缓存

## Dev Notes

### Data Models

**PreviewTask实体：**
```java
@Entity
@Table(name = "preview_tasks")
public class PreviewTask {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long userId;              // 用户ID
    private Long workId;              // 作品ID
    private Long productId;           // 商品ID
    private String color;             // 颜色
    private String size;              // 尺寸
    
    @Enumerated(EnumType.STRING)
    private TaskStatus status;        // 任务状态
    
    private String resultUrl;         // 结果URL
    private String errorMessage;      // 错误信息
    private Integer retryCount;       // 重试次数
    
    @CreatedDate
    private LocalDateTime createTime;
    
    @LastModifiedDate
    private LocalDateTime updateTime;
    
    // getters and setters
}
```

**任务状态枚举：**
```java
public enum TaskStatus {
    PENDING,      // 待处理
    PROCESSING,   // 处理中
    COMPLETED,    // 已完成
    FAILED        // 失败
}
```

**缓存Key生成：**
```java
public class PreviewCacheKey {
    public static String generate(Long workId, Long productId, String color, String size) {
        return String.format("preview:%d:%d:%s:%s", workId, productId, color, size);
    }
}
```

### API Specifications

**查询任务状态API：**
- GET /api/preview/tasks/{taskId}
- 响应格式：
```json
{
  "code": 200,
  "data": {
    "id": 123,
    "status": "COMPLETED",
    "progress": 100,
    "resultUrl": "https://oss.example.com/preview/xxx.jpg",
    "errorMessage": null,
    "createTime": "2024-12-17T10:00:00",
    "updateTime": "2024-12-17T10:00:08"
  }
}
```

### File Locations

**后端文件位置：**
```
backend/
├── src/main/java/com/aiprint/
│   ├── entity/
│   │   └── PreviewTask.java                    # 预览任务实体（新建）
│   ├── repository/
│   │   └── PreviewTaskRepository.java          # 任务Repository（新建）
│   ├── service/
│   │   ├── PreviewTaskService.java             # 任务服务接口（新建）
│   │   └── impl/
│   │       └── PreviewTaskServiceImpl.java     # 任务服务实现（新建）
│   ├── enums/
│   │   └── TaskStatus.java                     # 任务状态枚举（新建）
│   └── util/
│       └── PreviewCacheKey.java                # 缓存Key工具（新建）
```

### Technical Constraints

- **并发控制**: 使用数据库唯一索引避免重复任务
- **任务队列**: 使用数据库或Redis实现任务队列
- **异步执行**: 使用Spring @Async或消息队列
- **缓存策略**: 相同参数的任务结果缓存7天
- **重试机制**: 失败任务自动重试，最多3次

### 实现示例

**PreviewTaskService实现：**
```java
@Service
public class PreviewTaskServiceImpl implements PreviewTaskService {
    
    @Autowired
    private PreviewTaskRepository taskRepository;
    
    @Autowired
    private ImageEditService imageEditService;
    
    @Autowired
    private WorkRepository workRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Override
    public PreviewTask createTask(Long userId, Long workId, Long productId, String color, String size) {
        // 1. 检查缓存
        String cacheKey = PreviewCacheKey.generate(workId, productId, color, size);
        PreviewTask cachedTask = findCachedTask(cacheKey);
        if (cachedTask != null && cachedTask.getStatus() == TaskStatus.COMPLETED) {
            return cachedTask;
        }
        
        // 2. 创建新任务
        PreviewTask task = new PreviewTask();
        task.setUserId(userId);
        task.setWorkId(workId);
        task.setProductId(productId);
        task.setColor(color);
        task.setSize(size);
        task.setStatus(TaskStatus.PENDING);
        task.setRetryCount(0);
        task = taskRepository.save(task);
        
        // 3. 异步执行
        executeTaskAsync(task.getId());
        
        return task;
    }
    
    @Async
    protected void executeTaskAsync(Long taskId) {
        PreviewTask task = taskRepository.findById(taskId).orElse(null);
        if (task == null) return;
        
        try {
            // 1. 更新状态为PROCESSING
            task.setStatus(TaskStatus.PROCESSING);
            taskRepository.save(task);
            
            // 2. 获取图片URL
            Work work = workRepository.findById(task.getWorkId()).orElse(null);
            Product product = productRepository.findById(task.getProductId()).orElse(null);
            
            String workImageUrl = work.getImageUrl();
            String bagImageUrl = getBagImageUrl(product, task.getColor(), task.getSize());
            
            // 3. 调用图像编辑服务
            ImageEditRequest request = new ImageEditRequest();
            request.setWorkImageUrl(workImageUrl);
            request.setBagImageUrl(bagImageUrl);
            request.setPrompt(PromptTemplate.generateCompositePrompt(null));
            
            CompletableFuture<ImageEditResponse> future = imageEditService.compositeImage(request);
            ImageEditResponse response = future.get(30, TimeUnit.SECONDS);
            
            // 4. 更新任务结果
            if ("SUCCEEDED".equals(response.getStatus())) {
                task.setStatus(TaskStatus.COMPLETED);
                task.setResultUrl(response.getResultUrl());
            } else {
                task.setStatus(TaskStatus.FAILED);
                task.setErrorMessage(response.getErrorMessage());
            }
            taskRepository.save(task);
            
        } catch (Exception e) {
            log.error("预览任务执行失败", e);
            handleTaskFailure(task, e);
        }
    }
    
    private void handleTaskFailure(PreviewTask task, Exception e) {
        task.setRetryCount(task.getRetryCount() + 1);
        
        if (task.getRetryCount() < 3) {
            // 重试
            task.setStatus(TaskStatus.PENDING);
            taskRepository.save(task);
            
            // 延迟重试
            int delay = (int) Math.pow(2, task.getRetryCount()) * 5000; // 5s, 10s, 20s
            scheduleRetry(task.getId(), delay);
        } else {
            // 标记为失败
            task.setStatus(TaskStatus.FAILED);
            task.setErrorMessage(e.getMessage());
            taskRepository.save(task);
        }
    }
}
```

### Testing Requirements

后端测试：
- 单元测试：测试任务创建、查询、更新
- 集成测试：测试任务执行流程
- 性能测试：测试并发任务处理

## Testing

### Test Scenarios

1. **任务创建测试**
   - 创建预览任务
   - 验证任务记录已保存
   - 验证任务状态为PENDING
   - 验证异步执行已触发

2. **缓存命中测试**
   - 创建相同参数的任务
   - 验证第二次创建时直接返回缓存结果
   - 验证不会重复调用API

3. **任务查询测试**
   - 查询任务状态
   - 验证返回正确的状态和结果
   - 验证任务不存在时的处理

4. **重试机制测试**
   - 模拟任务失败
   - 验证自动重试
   - 验证重试间隔正确
   - 验证达到最大重试次数后标记为失败

5. **并发任务测试**
   - 同时创建多个任务
   - 验证任务队列正常工作
   - 验证不会创建重复任务

### Success Criteria

- PreviewTask实体创建成功
- 任务状态管理正常
- 任务进度查询正常
- 任务队列管理有效
- 重试机制正常工作
- 缓存机制有效

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-17 | 2.0 | 重构：改为预览任务管理 | PM |
| 2024-12-16 | 1.0 | 初始故事创建（位置调整方案） | PM |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

- 启用了 JPA Auditing (@EnableJpaAuditing) 支持 @CreatedDate 和 @LastModifiedDate
- 启用了 Spring Scheduling (@EnableScheduling) 支持定时任务
- 重试机制使用指数退避策略（5s, 10s, 20s）
- 缓存有效期设置为7天

### Completion Notes List

1. ✅ 创建 TaskStatus 枚举（PENDING, PROCESSING, COMPLETED, FAILED）
2. ✅ 创建 PreviewTask 实体，包含所有必需字段
3. ✅ 创建 PreviewTaskRepository，包含自定义查询方法
4. ✅ 创建 PreviewCacheKey 工具类生成缓存键
5. ✅ 实现 PreviewTaskService 接口和实现类
6. ✅ 实现任务创建逻辑，包含缓存检查和去重
7. ✅ 实现异步任务执行，调用 ImageEditService
8. ✅ 实现自动重试机制（最多3次，指数退避）
9. ✅ 实现定时任务：重试失败任务、清理过期任务
10. ✅ 创建 PreviewController 提供 REST API
11. ✅ 创建单元测试 PreviewTaskServiceTest

### File List

**新建文件：**
- `backend/src/main/java/com/myshop/enums/TaskStatus.java`
- `backend/src/main/java/com/myshop/entity/PreviewTask.java`
- `backend/src/main/java/com/myshop/repository/PreviewTaskRepository.java`
- `backend/src/main/java/com/myshop/util/PreviewCacheKey.java`
- `backend/src/main/java/com/myshop/service/PreviewTaskService.java`
- `backend/src/main/java/com/myshop/service/impl/PreviewTaskServiceImpl.java`
- `backend/src/main/java/com/myshop/controller/PreviewController.java`
- `backend/src/test/java/com/myshop/service/PreviewTaskServiceTest.java`

**修改文件：**
- `backend/src/main/java/com/myshop/AiPrintShopApplication.java` - 添加 @EnableJpaAuditing 和 @EnableScheduling

## QA Results

_To be filled by QA Agent_

