# Story 1.6: JWT认证中间件

## Status

Draft

## Story

**As a** developer,
**I want** to implement JWT authentication middleware,
**so that** protected API endpoints can verify user identity.

## Acceptance Criteria

1. JWT工具类已创建，支持token生成和验证
2. 认证拦截器已实现，拦截需要认证的接口
3. Token验证失败时返回401状态码
4. 前端请求自动携带token（从localStorage读取）
5. Token过期时自动跳转到登录页
6. 支持token刷新机制（可选）

## Tasks / Subtasks

- [ ] Task 1: 完善JWT工具类 (AC: 1)
  - [ ] 在Story 1.4创建的JwtUtil基础上完善
  - [ ] 实现从token中提取用户ID方法
  - [ ] 实现验证token有效性方法
  - [ ] 实现检查token是否过期方法
- [ ] Task 2: 创建认证拦截器 (AC: 2, 3)
  - [ ] 创建JwtAuthenticationInterceptor
  - [ ] 实现preHandle方法，拦截请求
  - [ ] 从请求头中提取token
  - [ ] 验证token有效性
  - [ ] Token无效时返回401状态码
  - [ ] 将用户ID存储到请求属性中
- [ ] Task 3: 配置拦截器 (AC: 2)
  - [ ] 创建WebMvcConfigurer配置类
  - [ ] 注册JwtAuthenticationInterceptor
  - [ ] 配置需要拦截的路径（/api/**，排除登录接口）
  - [ ] 配置排除路径（/api/auth/**，/api/health等）
- [ ] Task 4: 创建用户上下文工具类 (AC: 2)
  - [ ] 创建UserContext工具类
  - [ ] 实现从请求中获取当前用户ID方法
  - [ ] 在拦截器中设置用户ID到请求属性
- [ ] Task 5: 更新前端请求封装 (AC: 4, 5)
  - [ ] 在utils/request.js的请求拦截器中添加token
  - [ ] 从uni.getStorage读取token
  - [ ] 将token添加到请求头（Authorization: Bearer {token}）
  - [ ] 在响应拦截器中处理401错误
  - [ ] 401错误时清除token并跳转到登录页
- [ ] Task 6: 创建单元测试 (AC: 2, 3)
  - [ ] 创建JwtAuthenticationInterceptorTest
  - [ ] 测试有效token通过
  - [ ] 测试无效token返回401
  - [ ] 测试过期token返回401
  - [ ] 测试排除路径不拦截

## Dev Notes

### Previous Story Insights

依赖Story 1.4（微信登录API实现）和Story 1.5（前端微信登录实现）完成，确保JWT工具类已创建，前端能够获取和存储token。

### Data Models

使用Story 1.4创建的JWT工具类。Token中包含用户ID和基本信息。

**Token结构：**
- 载荷（Payload）：{ userId: number, nickName: string, ... }
- 过期时间：可配置（建议24小时）

[Source: docs/fullstack-architecture.md#API Specification]

### API Specifications

**认证机制：**
- 请求头：`Authorization: Bearer {token}`
- 需要认证的接口：除登录、健康检查外的所有/api/**接口
- 排除路径：/api/auth/wechat/login, /api/health, /api/products等公开接口

**响应格式：**
- 401 Unauthorized：Token无效或过期
- 响应体：`{ code: 401, message: "未授权，请先登录" }`

[Source: docs/fullstack-architecture.md#API Specification]

### File Locations

**后端文件位置：**
```
backend/src/main/java/com/myshop/
├── config/
│   ├── WebMvcConfig.java            # Web MVC配置
│   └── JwtAuthenticationInterceptor.java  # JWT认证拦截器
└── util/
    ├── JwtUtil.java                 # JWT工具类（更新）
    └── UserContext.java              # 用户上下文工具类
```

**前端文件位置：**
```
frontend/
└── utils/
    └── request.js                    # 网络请求封装（更新）
```

[Source: docs/fullstack-architecture.md#Repository Structure]

### Technical Constraints

- **JWT库**: java-jwt或jjwt（与Story 1.4一致）
- **拦截器**: 使用Spring的HandlerInterceptor
- **请求头格式**: Authorization: Bearer {token}
- **Token过期处理**: 前端自动跳转登录页

[Source: docs/fullstack-architecture.md#Tech Stack]

### Testing Requirements

- 使用JUnit 5和MockMvc进行拦截器测试
- 测试文件位置：`backend/src/test/java/com/myshop/config/JwtAuthenticationInterceptorTest.java`
- 测试有效token通过
- 测试无效token返回401
- 测试排除路径不拦截

[Source: docs/fullstack-architecture.md#Tech Stack]

## Testing

### Test File Location

测试文件应创建在：`backend/src/test/java/com/myshop/config/JwtAuthenticationInterceptorTest.java`

### Test Standards

- 使用JUnit 5和Spring Boot Test
- 使用MockMvc测试拦截器
- 使用Mockito Mock JWT工具类

### Test Scenarios

1. **有效token测试**
   - 发送带有有效token的请求
   - 验证请求能够通过拦截器
   - 验证用户ID能够正确提取

2. **无效token测试**
   - 发送带有无效token的请求
   - 验证返回401状态码
   - 验证错误信息正确

3. **过期token测试**
   - 发送带有过期token的请求
   - 验证返回401状态码

4. **排除路径测试**
   - 发送登录接口请求（不带token）
   - 验证请求能够通过拦截器

5. **前端token携带测试**
   - 验证前端请求能够自动携带token
   - 验证401错误时能够跳转登录页

### Success Criteria

- JWT工具类功能完善
- 认证拦截器能够正确拦截请求
- Token验证功能正常
- 前端能够自动携带token
- 401错误处理正确

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-15 | 1.0 | 初始故事创建 | Scrum Master |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_

